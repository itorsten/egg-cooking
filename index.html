<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Egg Cooking Simulator</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    canvas { max-width: 600px; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>Egg Cooking Simulator</h1>
  <div>
    <label>Total time (minutes):
      <input type="number" id="totalTime" value="10" min="1" step="0.5">
    </label>
  </div>
  <div>
    <label>Water temperature profile:
      <select id="profileType">
        <option value="constant">Constant</option>
        <option value="schedule">Time schedule</option>
      </select>
    </label>
  </div>
  <div id="constantInput">
    <label>Water temperature (째C):
      <input type="number" id="waterTemp" value="100">
    </label>
  </div>
  <div id="scheduleInput" style="display:none;">
    <p>Enter time,temperature pairs (seconds, 째C) separated by newline:</p>
    <textarea id="scheduleData" rows="4">0,10
120,100
480,100
481,10
600,10
</textarea>
  </div>
  <button id="runBtn">Run Simulation</button>
  <canvas id="tempChart"></canvas>
  <canvas id="cookChart"></canvas>

<script>
// Switch between constant and schedule inputs
const profileType = document.getElementById('profileType');
profileType.addEventListener('change', () => {
  const isConstant = profileType.value === 'constant';
  document.getElementById('constantInput').style.display = isConstant ? 'block' : 'none';
  document.getElementById('scheduleInput').style.display = isConstant ? 'none' : 'block';
});

// Parse schedule textarea into sorted time-temperature objects
function parseSchedule(text) {
  const lines = text.trim().split(/\n+/);
  const schedule = [];
  for (const line of lines) {
    const [t, temp] = line.split(',').map(Number);
    if (!isNaN(t) && !isNaN(temp)) {
      schedule.push({ t, temp });
    }
  }
  schedule.sort((a, b) => a.t - b.t);
  return schedule;
}

// Determine water temperature at time t
function getWaterTemp(t, profile) {
  if (profile.type === 'constant') return profile.temp;
  const sched = profile.schedule;
  if (t <= sched[0].t) return sched[0].temp;
  for (let i = 0; i < sched.length - 1; i++) {
    const a = sched[i], b = sched[i + 1];
    if (t >= a.t && t <= b.t) {
      const f = (t - a.t) / (b.t - a.t);
      return a.temp + f * (b.temp - a.temp);
    }
  }
  return sched[sched.length - 1].temp;
}

// Run ODE simulation and plot results
function runSimulation() {
  const totalTime = Number(document.getElementById('totalTime').value*60);
  const dt = 0.1; // Solver time step in seconds
  const steps = Math.round(totalTime / dt);
  const outputTimestep = 15; // Seconds between output points
  const outputDecimation = Math.max(1, Math.round(outputTimestep / dt));

  // Build water temperature profile
  const type = profileType.value;
  let profile;
  if (type === 'constant') {
    profile = { type: 'constant', temp: Number(document.getElementById('waterTemp').value) };
  } else {
    profile = { type: 'schedule', schedule: parseSchedule(document.getElementById('scheduleData').value) };
  }

  // Parameters
  const C_albumen = 3800;      // heat capacity of albumen [J/(kg*K)]
  const C_yolk = 3120;         // heat capacity of yolk [J/(kg*K)]
  const k_albumenyolk = 0.35;   // conductance albumen-yolk [W/K]
  const h_shell = 500;         // convective heat transfer coefficient [W/(m^2*K)]
  const A_shell = 0.003;       // eggshell surface area [m^2]
  const mass_albumen = 0.025;   // mass of albumen in egg [kg]
  const mass_yolk = 0.02;     // mass of yolk in egg [kg]
  
  const k0_albumen = 4.85e60;  // pre-exponential factor for albumen denaturation [s^-1]
  const Ea_albumen = 4.185e5;  // activation energy for albumen [J/mol]
  const k0_yolk = 2.72e50;     // pre-exponential factor for yolk denaturation [s^-1]
  const Ea_yolk = 3.443e5;     // activation energy for yolk [J/mol]
  const R = 8.314;             // universal gas constant [J/(mol*K)]

  // Initial states
  let T_albumen = 20+273.15;   // temperature of the albumen [K]
  let T_yolk = 20+273.15;      // temperature of the yolk [K]
  let X_albumen = 0;           // albumen cooking degree [fraction]
  let X_yolk = 0;              // yolk cooking degree [fraction]

  const time = [], uTemp = [], yTemp = [], aTemp = [], yCook = [], aCook = [];
  for (let i = 0; i <= steps; i++) {
    // Get time and inputs
    const t = i * dt;
    const T_env = getWaterTemp(t, profile) + 273.15; // temperature of surrounding water [K]

    // Store outputs
    if (i % outputDecimation === 0 || i === steps) {
      time.push(t/60); // Convert to minutes for display
      uTemp.push(T_env - 273.15); // Convert K to 째C for display
      yTemp.push(T_yolk - 273.15);
      aTemp.push(T_albumen - 273.15);
      yCook.push(X_yolk);
      aCook.push(X_albumen);
    }

    // Update model...

    // Heat flows
    const Q_env_albumen = h_shell * A_shell * (T_env - T_albumen); // environment to albumen [W]
    const Q_albumen_yolk = k_albumenyolk * (T_albumen - T_yolk);   // albumen to yolk [W]

    // Energy balances
    const dT_albumen = (Q_env_albumen - Q_albumen_yolk) / (mass_albumen * C_albumen);
    const dT_yolk = Q_albumen_yolk / (mass_yolk * C_yolk);

    // Denaturation kinetics
    const dX_albumen = (1 - X_albumen) * Math.exp(-Ea_albumen / (R * T_albumen)) * k0_albumen;
    const dX_yolk = (1 - X_yolk) * Math.exp(-Ea_yolk / (R * T_yolk)) * k0_yolk;

    // Euler integration
    T_albumen += dt * dT_albumen;
    T_yolk    += dt * dT_yolk;
    X_albumen += dt * dX_albumen;
    X_yolk    += dt * dX_yolk;

    // Clamp cooking degrees between 0 and 1
    X_albumen = Math.min(X_albumen, 1);
    X_yolk = Math.min(X_yolk, 1);
  }

  plotResults(time, uTemp, yTemp, aTemp, yCook, aCook);
}

document.getElementById('runBtn').addEventListener('click', runSimulation);

let tempChart, cookChart;
function plotResults(time, uTemp, yTemp, aTemp, yCook, aCook) {
  if (tempChart) tempChart.destroy();
  if (cookChart) cookChart.destroy();

  const ctxT = document.getElementById('tempChart');
  tempChart = new Chart(ctxT, {
    type: 'line',
    data: {
      labels: time,
      datasets: [
        { label: 'Water', data: uTemp, borderColor: 'blue', fill: false },
        { label: 'Yolk', data: yTemp, borderColor: 'orange', fill: false },
        { label: 'Albumen', data: aTemp, borderColor: 'grey', fill: false }
      ]
    },
    options: {
      scales: {
        x: { title: { display: true, text: 'Time (min)' } },
        y: { title: { display: true, text: 'Temp (째C)' } }
      }
    }
  });

  const ctxC = document.getElementById('cookChart');
  cookChart = new Chart(ctxC, {
    type: 'line',
    data: {
      labels: time,
      datasets: [
        { label: 'Yolk', data: yCook, borderColor: 'orange', fill: false },
        { label: 'Albumen', data: aCook, borderColor: 'grey', fill: false }
      ]
    },
    options: {
      scales: {
        x: { title: { display: true, text: 'Time (min)' } },
        y: { title: { display: true, text: 'Cooking Degree' } }
      }
    }
  });
}
</script>
</body>
</html>
